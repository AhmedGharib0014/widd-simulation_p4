@startuml WIDD System Architecture

!theme plain
skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<Controller>> LightBlue
    BackgroundColor<<Detection>> LightGreen
    BackgroundColor<<Attack>> LightCoral
    BackgroundColor<<Data>> Wheat
    BackgroundColor<<Network>> LightCyan
    BackgroundColor<<Enum>> LightGray
    BorderColor Black
    ArrowColor Black
}

title WIDD System - Class Architecture\n(Based on Actual Code Implementation)

' ==================== PACKET FORMATS ====================
package "Packet Formats" <<Data>> {

    class "WIDD Frame Format\n(attack_generator.py)" as WIDDFrame <<Data>> {
        == Ethernet Header (14 bytes) ==
        +dst_mac: bytes[6]
        +src_mac: bytes[6]
        +ethertype: 0x88B5
        == 802.11 Frame Control (2 bytes) ==
        +protocol_version: bit[2]
        +frame_type: bit[2]
        +subtype: bit[4]
        +flags: bit[8]
        == 802.11 Addresses (20 bytes) ==
        +addr1: bytes[6] (Receiver)
        +addr2: bytes[6] (Transmitter)
        +addr3: bytes[6] (BSSID)
        +seq_ctrl: bytes[2]
        == RF Features (8 bytes) ==
        +rssi: int16
        +phase_offset: uint16
        +pilot_offset: uint16
        +mag_squared: uint16
        == Payload (variable) ==
        +payload: bytes
    }

    class "CPU Header\n(P4 prepends this)" as CPUHeader <<Data>> {
        +reason: uint8
        +orig_port: uint8
        +rf_rssi: int16
        --
        Total: 4 bytes
        --
        reason codes:
        1 = deauth
        2 = assoc
        3 = auth
        4 = beacon
        5 = disassoc
        6 = data
    }

    class "P4 Output Packet Format" as P4Output <<Data>> {
        == Order of emission ==
        1. cpu_header_t (4 bytes)
        2. ethernet_t (14 bytes)
        3. wifi_fc_t (2 bytes)
        4. wifi_addr_t (20 bytes)
        5. rf_features_t (8 bytes)
        --
        Total header: 48 bytes
    }

    note right of WIDDFrame
        **802.11 Frame Types:**
        0 = Management
        1 = Control
        2 = Data

        **Management Subtypes:**
        0x0 = Assoc Req
        0x8 = Beacon
        0xA = Disassoc
        0xB = Auth
        0xC = Deauth
    end note
}

' ==================== P4 SWITCH (widd.p4) ====================
package "P4 Data Plane (widd.p4)" <<Network>> {

    class P4Switch <<Network>> {
        == Constants ==
        {static} +ETHERTYPE_WIDD: 0x88B5
        {static} +CPU_PORT: 255
        {static} +THRIFT_PORT: 9090
        == Headers Parsed ==
        +ethernet_t
        +wifi_fc_t
        +wifi_addr_t
        +rf_features_t
        +cpu_header_t
        == Actions ==
        +drop()
        +forward(port)
        +send_to_cpu(reason)
        +flood()
        == Tables ==
        +l2_forward
        +device_lookup
        +blocklist
    }

    class "WiddParser" as Parser <<Network>> {
        +parse_ethernet()
        +parse_wifi_fc()
        +parse_wifi_addr()
        +parse_rf_features()
        +parse_cpu_header()
        --
        Handles both Packet-In
        and Packet-Out paths
    }

    class "WiddIngress" as Ingress <<Network>> {
        +frameCounter: counter
        +knownDevices: register
        --
        +apply()
        -check blocklist
        -check frame type
        -send mgmt frames to CPU
        -handle Packet-Out forwarding
    }

    class "WiddDeparser" as Deparser <<Network>> {
        +emit(cpu)
        +emit(ethernet)
        +emit(wifiFC)
        +emit(wifiAddr)
        +emit(rfFeatures)
        --
        Only emits valid headers
    }
}

' ==================== TOPOLOGY (widd_topo.py) ====================
package "Network Topology (widd_topo.py)" <<Network>> {

    class P4SwitchClass <<Network>> {
        +name: str = "s1"
        +sw_path: str = "simple_switch"
        +json_path: str
        +thrift_port: int = 9090
        +bmv2_pid: int
        --
        +start(controllers)
        +stop()
        --
        Creates veth pair:
        s1-cpu-h <-> s1-cpu-s
    }

    class "create_topology()" as Topology <<Network>> {
        == Network Components ==
        +ap1: AccessPoint
        +s1: P4Switch
        +sta1, sta2: Station
        +attacker: Station
        == Connections ==
        ap1 <-> s1 (ap1-eth1 <-> s1-eth1)
        s1 <-> controller (s1-cpu-s <-> s1-cpu-h)
        == Traffic Mirroring ==
        tc mirred: ap1-wlan -> ap1-eth1
    }
}

' ==================== SWITCH INTERFACE ====================
package "Switch Interface (switch_interface.py)" <<Controller>> {

    class WIDDFrameInfo <<Data>> {
        +frame_type: str
        +subtype: str
        +frame_type_num: int
        +subtype_num: int
        +src_mac: str
        +dst_mac: str
        +bssid: str
        +seq_ctrl: int
        +rssi: int
        +phase: int
        +pilot: int
        +mag: int
        +cpu_reason: int
        +cpu_orig_port: int
        +raw_payload: bytes
        +raw_bytes: bytes
        +error: str
    }

    class PacketInEvent <<Controller>> {
        +raw_packet: bytes
        +reason: int
        +orig_port: int
        +rssi: int
        +payload: bytes
        +frame_info: WIDDFrameInfo
        --
        +_parse()
        +_parse_widd_frame(): WIDDFrameInfo
        +get_reason_name(): str
        +to_dict(): dict
    }

    class SwitchInterface <<Controller>> {
        +thrift_ip: str
        +thrift_port: int
        +cpu_iface: str
        +client: Standard.Client
        +packet_in_callback: Callable
        +stop_event: Event
        --
        +connect(): bool
        +disconnect()
        +add_table_entry(...)
        +delete_table_entry(...)
        +block_attacker(mac): int
        +unblock_attacker(handle): bool
        +read_register(name, idx): int
        +write_register(name, idx, val): bool
        +read_counter(name, idx): tuple
        +start_packet_in_listener(callback, iface)
        +stop_packet_in_listener()
        +send_packet_out(port, packet): bool
        -_packet_in_loop(iface)
    }

    note right of SwitchInterface
        **Unified Interface:**
        - Thrift API for table management
        - Scapy sniff for Packet-In
        - Raw socket for Packet-Out
        - WIDD frame parsing
    end note
}

' ==================== OODA CONTROLLER ====================
package "OODA Controller (controller/)" <<Controller>> {

    class ParsedFrame <<Data>> {
        +eth_dst: bytes
        +eth_src: bytes
        +eth_type: int
        +frame_type: int
        +subtype: int
        +addr1: str
        +addr2: str
        +addr3: str
        +rssi: int
        +phase_offset: int
        +pilot_offset: int
        +mag_squared: int
        +cpu_reason: int
        +orig_port: int
        +raw_bytes: bytes
    }

    class OODAController <<Controller>> {
        +switch: SwitchInterface
        +mocc: MOCC
        +kcsm: KCSMManager
        +known_clients: list
        +stats: dict
        +network_ssid: str
        +network_bssid: str
        --
        +set_network_info(ssid, bssid)
        +register_client(mac, rssi)
        +simulate_frame(type, mac, ...)
        +get_stats(): dict
        -_process_deauth(frame, rf)
        -_process_disassoc(frame, rf)
        -_process_auth(frame)
        -_process_assoc(frame)
        -_process_beacon(frame)
        -_process_data(frame, rf)
        -_forward_frame(frame): bool
        -_block_attacker(mac): bool
    }

    class MOCC <<Detection>> {
        -device_signatures: dict
        -device_rssi: dict
        --
        {static} +THRESHOLD: float = 0.35
        --
        +register_device(mac, rssi)
        +train(mac, rf_features)
        +identify(mac, rf_features): tuple
        +get_training_status(mac): dict
        +get_probability(mac, rf_features): float
    }

    class RFFeatures <<Data>> {
        +rssi: int
        +phase_offset: int
        +pilot_offset: int
        +mag_squared: int
    }

    class KCSMManager <<Detection>> {
        +deauth_kcsm: DeauthKCSM
        +disassoc_kcsm: DisassocKCSM
        +auth_flood_kcsm: AuthFloodKCSM
        +assoc_flood_kcsm: AssocFloodKCSM
        --
        +process_deauth(mac, is_legit): tuple
        +process_disassoc(mac, is_legit): tuple
        +process_auth(): AttackType
        +process_assoc(): AttackType
        +process_beacon(ssid, bssid): AttackType
    }

    class WIDDLogger <<Controller>> {
        +use_colors: bool
        +stats: dict
        --
        +system_info(msg)
        +system_start(component)
        +system_stop(component)
        +ooda_observe(frame_type, mac)
        +ooda_orient_mocc(mac, prob, legit)
        +ooda_decide_drop(reason, mac)
        +ooda_decide_pass(mac)
        +attack_detected(msg)
        +print_stats()
    }
}

' ==================== START_SERVER ====================
package "Server Entry Point (start_server.py)" <<Controller>> {

    class "main()" as StartServer <<Controller>> {
        == Initialization ==
        +controller: OODAController
        +switch_interface: SwitchInterface
        == Functions ==
        +handle_packet(event: PacketInEvent)
        --
        1. Creates OODAController
        2. Trains MOCC with data frames
        3. Starts SwitchInterface listener
        4. Processes Packet-In events
    }
}

' ==================== ATTACK GENERATION ====================
package "Attack Generation (attacks/)" <<Attack>> {

    class AttackGenerator <<Attack>> {
        +interface: str
        +wap_mac: str = "00:11:22:33:44:55"
        +wap_bssid: str
        +attacker_rssi: int = -60
        +attacker_phase: int = 350
        +attacker_pilot: int = 150
        +attacker_mag: int = 3500
        --
        +send_frame(frame, dst_mac, src_mac)
        +deauth_attack(victim, count, interval, spoof): int
        +disassoc_attack(victim, count, interval)
        +auth_flood(count, interval)
        +assoc_flood(count, interval)
        +evil_twin_beacon(ssid, count, interval)
        +generate_legitimate_data(mac, count, rssi, ...)
    }

    class "build_widd_frame()" as BuildFrame <<Attack>> {
        +frame_type: int
        +subtype: int
        +dst_mac: str
        +src_mac: str
        +bssid: str
        +rssi: int
        +phase: int
        +pilot: int
        +mag: int
        +payload: bytes
        --
        Returns: bytes (WIDD payload)
    }
}

' ==================== INTERACTIVE CLI ====================
package "Interactive CLI (interactive_attack.py)" <<Attack>> {

    class InteractiveAttackCLI <<Attack>> {
        +interface: str
        +attack_gen: AttackGenerator
        +clients: dict
        +attacker_mac: str = "00:00:00:00:00:99"
        +wap_mac: str = "00:11:22:33:44:55"
        +wap_bssid: str
        --
        +initialize()
        +resolve_mac(name_or_mac): str
        +cmd_deauth(args)
        +cmd_disassoc(args)
        +cmd_evil_twin(args)
        +cmd_auth_flood(args)
        +cmd_assoc_flood(args)
        +cmd_data(args)
        +cmd_train(args)
        +cmd_demo1..demo4(args)
        +run()
    }
}

' ==================== DEMO LAUNCHER ====================
package "Demo Launcher (demo_launcher.sh)" {

    class DemoLauncher {
        == xterm Windows ==
        +TERM_MININET: Mininet CLI
        +TERM_CONTROLLER: start_server.py
        +TERM_ATTACKER: interactive_attack.py
        == Functions ==
        +compile_p4()
        +launch_mininet()
        +launch_controller()
        +launch_attacker()
        +cleanup()
    }
}

' ==================== RELATIONSHIPS ====================

' Packet format relationships
CPUHeader -right-> P4Output : prepended to
WIDDFrame -right-> P4Output : follows CPU header

' P4 internal
Parser -down-> Ingress
Ingress -down-> Deparser
P4Switch *-- Parser
P4Switch *-- Ingress
P4Switch *-- Deparser

' Topology to P4
P4SwitchClass ..> P4Switch : runs

' Switch Interface
PacketInEvent *-- WIDDFrameInfo
SwitchInterface ..> PacketInEvent : creates
Deparser -down-> SwitchInterface : emits to s1-cpu-h

' OODA Controller
StartServer *-- OODAController
StartServer *-- SwitchInterface
SwitchInterface -down-> StartServer : callback
OODAController *-- MOCC
OODAController *-- KCSMManager
OODAController ..> WIDDLogger : uses
OODAController ..> ParsedFrame : creates
OODAController ..> RFFeatures : creates
OODAController -up-> SwitchInterface : send_packet_out()

' Attack generation
InteractiveAttackCLI *-- AttackGenerator
AttackGenerator ..> BuildFrame : uses
AttackGenerator ..> WIDDFrame : creates

' Demo launcher
DemoLauncher ..> Topology : starts
DemoLauncher ..> StartServer : starts
DemoLauncher ..> InteractiveAttackCLI : starts

@enduml
