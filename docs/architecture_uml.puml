@startuml WIDD System Architecture

!theme plain
skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<Controller>> LightBlue
    BackgroundColor<<Detection>> LightGreen
    BackgroundColor<<Attack>> LightCoral
    BackgroundColor<<Data>> Wheat
    BackgroundColor<<Network>> LightCyan
    BackgroundColor<<Enum>> LightGray
    BorderColor Black
    ArrowColor Black
}

title WIDD System - Class Architecture\n(Based on Actual Code Implementation)

' ==================== PACKET FORMATS ====================
package "Packet Formats" <<Data>> {

    class "WIDD Frame Format\n(attack_generator.py)" as WIDDFrame <<Data>> {
        == Ethernet Header (14 bytes) ==
        +dst_mac: bytes[6]
        +src_mac: bytes[6]
        +ethertype: 0x88B5
        == 802.11 Frame Control (2 bytes) ==
        +protocol_version: bit[2]
        +frame_type: bit[2]
        +subtype: bit[4]
        +flags: bit[8]
        == 802.11 Addresses (20 bytes) ==
        +addr1: bytes[6] (Receiver)
        +addr2: bytes[6] (Transmitter)
        +addr3: bytes[6] (BSSID)
        +seq_ctrl: bytes[2]
        == RF Features (8 bytes) ==
        +rssi: int16
        +phase_offset: uint16
        +pilot_offset: uint16
        +mag_squared: uint16
        == Payload (variable) ==
        +payload: bytes
    }

    class "CPU Header\n(P4 prepends this)" as CPUHeader <<Data>> {
        +reason: uint8
        +orig_port: uint8
        +rf_rssi: int16
        --
        Total: 4 bytes
        --
        reason codes:
        1 = deauth
        2 = assoc
        3 = auth
        4 = beacon
        5 = disassoc
        6 = data
    }

    class "P4 Output Packet Format" as P4Output <<Data>> {
        == Order of emission ==
        1. cpu_header_t (4 bytes)
        2. ethernet_t (14 bytes)
        3. wifi_fc_t (2 bytes)
        4. wifi_addr_t (20 bytes)
        5. rf_features_t (8 bytes)
        --
        Total header: 48 bytes
    }

    note right of WIDDFrame
        **802.11 Frame Types:**
        0 = Management
        1 = Control
        2 = Data

        **Management Subtypes:**
        0x0 = Assoc Req
        0x8 = Beacon
        0xA = Disassoc
        0xB = Auth
        0xC = Deauth
    end note
}

' ==================== P4 SWITCH (widd.p4) ====================
package "P4 Data Plane (widd.p4)" <<Network>> {

    class P4Switch <<Network>> {
        == Constants ==
        {static} +ETHERTYPE_WIDD: 0x88B5
        {static} +CPU_PORT: 255
        {static} +THRIFT_PORT: 9090
        == Headers Parsed ==
        +ethernet_t
        +wifi_fc_t
        +wifi_addr_t
        +rf_features_t
        +cpu_header_t
        == Actions ==
        +drop()
        +forward(port)
        +send_to_cpu(reason)
        +flood()
        == Tables ==
        +l2_forward
        +device_lookup
    }

    class "WiddParser" as Parser <<Network>> {
        +parse_ethernet()
        +parse_wifi_fc()
        +parse_wifi_addr()
        +parse_rf_features()
    }

    class "WiddIngress" as Ingress <<Network>> {
        +frameCounter: counter
        +knownDevices: register
        --
        +apply()
        -check frame type
        -send mgmt frames to CPU
        -send data frames to CPU
    }

    class "WiddDeparser" as Deparser <<Network>> {
        +emit(cpu)
        +emit(ethernet)
        +emit(wifiFC)
        +emit(wifiAddr)
        +emit(rfFeatures)
    }
}

' ==================== TOPOLOGY (widd_topo.py) ====================
package "Network Topology (widd_topo.py)" <<Network>> {

    class P4SwitchClass <<Network>> {
        +name: str = "s1"
        +sw_path: str = "simple_switch"
        +json_path: str
        +thrift_port: int = 9090
        +bmv2_pid: int
        --
        +start(controllers)
        +stop()
        --
        Creates veth pair:
        s1-cpu-h <-> s1-cpu-s
    }

    class "create_topology()" as Topology <<Network>> {
        == Network Components ==
        +ap1: AccessPoint
        +s1: P4Switch
        +sta1, sta2, sta3: Station
        +attacker: Station
        == Connections ==
        ap1 <-> s1 (ap1-eth1 <-> s1-eth1)
        s1 <-> controller (s1-cpu-s <-> s1-cpu-h)
        == Traffic Mirroring ==
        tc mirred: ap1-wlan -> ap1-eth1
    }
}

' ==================== PACKET RECEIVER ====================
package "Packet Receiver (packet_receiver.py)" <<Controller>> {

    class PacketReceiver <<Controller>> {
        +interface: str = "s1-cpu-h"
        +callback: Callable
        +running: bool
        +thread: Thread
        --
        +start()
        +stop()
        -_sniff_packets()
        -_handle_packet(pkt)
        -_parse_widd_frame(payload): dict
        --
        Uses Scapy sniff()
    }

    class "frame_info dict" as FrameInfo <<Data>> {
        +frame_type: str
        +subtype: str
        +frame_type_num: int
        +subtype_num: int
        +src_mac: str
        +dst_mac: str
        +bssid: str
        +seq_ctrl: int
        +rssi: int
        +phase: int
        +pilot: int
        +mag: int
        +cpu_reason: int
        +cpu_orig_port: int
        +raw_payload: bytes
    }
}

' ==================== OODA CONTROLLER ====================
package "OODA Controller (controller/)" <<Controller>> {

    class OODAController <<Controller>> {
        +mocc: MOCC
        +kcsm: KCSMManager
        +known_clients: list
        +stats: dict
        --
        +register_client(mac, rssi)
        +process_frame(frame_info)
        +get_stats(): dict
    }

    class MOCC <<Detection>> {
        -device_signatures: dict
        -device_rssi: dict
        --
        {static} +THRESHOLD: float = 0.35
        --
        +register_device(mac)
        +update_device_rssi(mac, rssi)
        +add_sample(mac, rf_features)
        +verify_device(mac, rf_features): bool
        +is_device_registered(mac): bool
        +get_probability(mac, rf_features): float
    }

    class KCSMManager <<Detection>> {
        -client_states: dict
        -attack_counts: dict
        --
        +process_deauth(mac, is_legitimate)
        +process_disassoc(mac, is_legitimate)
        +process_auth(mac)
        +process_assoc(mac)
        +process_beacon(ssid, bssid)
        +report_attack(mac, attack_type)
        +get_stats(): dict
    }

    class WIDDLogger <<Controller>> {
        +use_colors: bool
        +stats: dict
        --
        +system_info(msg)
        +system_start(component)
        +system_stop(component)
        +attack_detected(msg)
        +print_stats()
    }
}

' ==================== START_SERVER ====================
package "Server Entry Point (start_server.py)" <<Controller>> {

    class "main()" as StartServer <<Controller>> {
        == Initialization ==
        +controller: OODAController
        +receiver: PacketReceiver
        == UDP Monitor ==
        +monitor_socket: UDP
        +MONITOR_ADDR: (127.0.0.1, 9998)
        == Functions ==
        +send_event(stage, frame_type, src_mac, details)
        +handle_packet(frame_info)
        --
        Listens on s1-cpu-h
        Sends UDP events to packet_monitor
    }
}

' ==================== ATTACK GENERATION ====================
package "Attack Generation (attacks/)" <<Attack>> {

    class AttackGenerator <<Attack>> {
        +interface: str
        +wap_mac: str = "00:11:22:33:44:55"
        +wap_bssid: str
        +attacker_rssi: int = -60
        +attacker_phase: int = 350
        +attacker_pilot: int = 150
        +attacker_mag: int = 3500
        --
        +send_frame(frame, dst_mac, src_mac)
        +deauth_attack(victim_mac, count, interval, spoof): int
        +disassoc_attack(victim_mac, count, interval)
        +auth_flood(count, interval)
        +assoc_flood(count, interval)
        +evil_twin_beacon(ssid, count, interval)
        +generate_legitimate_data(client_mac, count, rssi, phase, pilot, mag)
    }

    class "build_widd_frame()" as BuildFrame <<Attack>> {
        +frame_type: int
        +subtype: int
        +dst_mac: str
        +src_mac: str
        +bssid: str
        +rssi: int
        +phase: int
        +pilot: int
        +mag: int
        +payload: bytes
        --
        Returns: bytes (WIDD payload)
    }

    class "build_wifi_fc()" as BuildFC <<Attack>> {
        +frame_type: int
        +subtype: int
        --
        fc = (frame_type << 2) | (subtype << 4)
        Returns: struct.pack('!H', fc)
    }
}

' ==================== INTERACTIVE CLI ====================
package "Interactive CLI (interactive_attack.py)" <<Attack>> {

    class InteractiveAttackCLI <<Attack>> {
        +interface: str
        +attack_gen: AttackGenerator
        +clients: dict
        +attacker_mac: str = "00:00:00:00:00:99"
        +wap_mac: str = "00:11:22:33:44:55"
        +wap_bssid: str
        --
        +initialize()
        +resolve_mac(name_or_mac): str
        +cmd_deauth(args)
        +cmd_disassoc(args)
        +cmd_evil_twin(args)
        +cmd_auth_flood(args)
        +cmd_assoc_flood(args)
        +cmd_data(args)
        +cmd_train(args)
        +cmd_demo1..demo4(args)
        +run()
    }
}

' ==================== PACKET MONITOR ====================
package "Packet Monitor (packet_monitor.py)" <<Controller>> {

    class PacketMonitor <<Controller>> {
        +port: int = 9998
        +running: bool
        +sock: UDP socket
        --
        +start()
        +stop()
        +display_event(event)
        --
        Listens for UDP events
        from start_server.py
    }
}

' ==================== DEMO LAUNCHER ====================
package "Demo Launcher (demo_launcher.sh)" {

    class DemoLauncher {
        == xterm Windows ==
        +TERM_MININET: Mininet CLI
        +TERM_CONTROLLER: start_server.py
        +TERM_ATTACKER: interactive_attack.py
        +TERM_MONITOR: packet_monitor.py
        == Functions ==
        +compile_p4()
        +launch_mininet()
        +launch_controller()
        +launch_attacker()
        +launch_monitor()
        +cleanup()
    }
}

' ==================== RELATIONSHIPS ====================

' Packet format relationships
CPUHeader -right-> P4Output : prepended to
WIDDFrame -right-> P4Output : follows CPU header

' P4 internal
Parser -down-> Ingress
Ingress -down-> Deparser
P4Switch *-- Parser
P4Switch *-- Ingress
P4Switch *-- Deparser

' Topology to P4
P4SwitchClass ..> P4Switch : runs

' Packet flow
Deparser -down-> PacketReceiver : emits to s1-cpu-h
PacketReceiver ..> FrameInfo : creates
PacketReceiver -down-> StartServer : callback

' OODA Controller
StartServer *-- OODAController
OODAController *-- MOCC
OODAController *-- KCSMManager
OODAController ..> WIDDLogger : uses

' Attack generation
InteractiveAttackCLI *-- AttackGenerator
AttackGenerator ..> BuildFrame : uses
BuildFrame ..> BuildFC : uses
AttackGenerator ..> WIDDFrame : creates

' Monitor
StartServer ..> PacketMonitor : UDP events

' Demo launcher
DemoLauncher ..> Topology : starts
DemoLauncher ..> StartServer : starts
DemoLauncher ..> InteractiveAttackCLI : starts
DemoLauncher ..> PacketMonitor : starts

' ==================== NOTES ====================

note bottom of BuildFC
    **POTENTIAL ISSUE:**
    802.11 FC uses little-endian on wire
    but struct.pack('!H', fc) uses big-endian
    This may cause parsing issues in P4
end note

note right of PacketReceiver
    **Current Issue:**
    Packets arriving show "No Ethernet layer"
    or wrong ethertype (0x86DD instead of 0x88B5)

    mininet-wifi wireless simulation
    may be transforming the packet format
end note

@enduml
